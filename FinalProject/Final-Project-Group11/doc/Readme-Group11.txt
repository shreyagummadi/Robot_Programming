# ENPM809Y_Group11: Introduction to Robot Programming 
# Final Project: OOP, Inheritance, and Dynamic Polymorphism


Project Statement
========
We are tasked to develop only the structure of a project using object-oriented programming, inheritance, and dynamic polymorphism, that will be used to drive one of two robot in a maze, to reach the goal location which is the center of the maze


It is currently hosted on GitHub at 

https://github.com/sully892/Cu_Ag_Au/Final-Project-Group11


Files
========
 
There is one file for this project:
	Final-Project-Group11.zip

To run the file, extract and open the workspace in any IDE, build, and run the main.cpp file. 

The program consists of the following files:

main.cpp
landbasedrobot.h
landbasedrobot.cpp
landbasedtracked.h
landbasedtracked.cpp
landbasedwheeled.h
landbasedwheeled.cpp
algorithm.h
algorithm.cpp
api.h
app.cpp
byte.h
direction.h
maze.h
maze.cpp


Overview
========

* The scenario uses two types of robots that have a different driving mechanism and characteristics.

* The Ô¨Årst robot belongs to the C++ class LandBasedWheeled, which is a derived concrete class

* The second robot belongs to the C++ class LandBasedTracked, which is a derived concrete class

* Both classes derive from the base class LandBasedRobot, which is an abstract base class


User Inputs
-----

In the Micromouse Simulator input the following:

* Name: finalproject
* Directory: /Desktop/Workspace/FinalProject/Final-Project-Group11/src
* Build command: g++ API/api.cpp LandBasedRobot/landbasedrobot.cpp LandBasedTracked/landbasedtracked.cpp LandBasedWheeled/landbasedwheeled.cpp Maze/maze.cpp Algorithm/algorithm.cpp Main/main.cpp
* Run Command: ./a.out


Program Output
------

* Generate path from current position (S)(0,0) to the center of the maze (G)(7,7;7,8;8,7;8,8)
* After a path is found and generated
		-Using down, right, up, left sequence
* A robot will follow the path using the function
		-After each turn of the robot the function MoveFoward needs to be call each time
* Micromouse simulator will be used to display the result on the screen
* Program exits when
		*Robot reaches G or
		*There is no solution from S to G


To run the file:
------

	-Step 1: Extract and open the workspace in any IDE, then build and run the main.cpp file. 
		~The zip file might contains adjacent files, make sure to that it is stored in the workspace 
		for the code to run. Otherwise. specify the location address in the code.

	-Step 2: In the Micromouse Simulator input the following:

		* Name: finalproject
		* Directory: /Desktop/Workspace/FinalProject/Final-Project-Group11/src
		* Build command: g++ API/api.cpp LandBasedRobot/landbasedrobot.cpp LandBasedTracked/landbasedtracked.cpp LandBasedWheeled/landbasedwheeled.cpp Maze/maze.cpp Algorithm/algorithm.cpp Main/main.cpp
		* Run Command: ./a.out

To install Micromouse simulator:
------
	- git clone https://github.com/mackorone/mms
	- cd mms/src 
	- qmake && make

To launch Mircormouse simulator:
------
	- ./bin/mms

Maze:
------

* All maze have the same dimensions 16 x 16 cells [0,15] by [0,15]
* All maze have walls around their perimeter
		-The robot has not previous knowledge of any wall including the perimeter walls.
		-Walls are discovered only when robot tries to drive through a wall
* All maze have the same goal at the center with coordinates (7,7;7,8;8,7;8,8)

Robot:
-----

* Robot will be choose from Wheeled:Husky vs Tracked:LT2-F
* Robot will always start at position (0,0), and will always face north.

Micromouse Simulator:
-----

The micromouse simulator (https://github.com/mackorone/mms) is a small C ++ QT simulator that allows you to visualize path planning
algorithms.

* Generates maze, Add walls and Visualize maze
		1. see robot move
		2. walls being added in the maze
		3. show the path generated by search algorithm
			-interact using build-in methods from mms project with class API



